## [Разные системные API для ESP32](#)

---

### [Miscellaneous System APIs](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/misc_system_api.html#_CPPv411esp_restartv)

#### Сброс программного обеспечения

Для выполнения программного сброса чипа предусмотрена функция ***esp_restart()***. При вызове функции выполнение программы останавливается, оба процессора сбрасываются, приложение загружается загрузчиком и снова начинает выполнение.

Кроме того, ***esp_register_shutdown_handler()*** функция может зарегистрировать процедуру, которая будет автоматически вызываться перед перезапуском (который запускается esp_restart()). 

[void esp_restart(void)]()

Перезапустить процессоры PRO и APP.

> *PRO и APP - так называются два ядра: core 0 - PRO, core 1 - APP.*
> 
> *Это устаревшие названия. Первоначальный дизайн ESP32 предусматривал асимметричную многопроцессорную настройку, при которой в CPU0 запускался весь код обработки протокола, в то время как приложение работало бы на CPU1. Позже мы изменили это на симметричную многопроцессорную настройку, и на данный момент два процессора (за очень немногими небольшими исключениями) полностью взаимозаменяемы.*
> 
> *Опции, которые вы можете использовать для перемещения различных системных задач между двумя ядрами:*
> 
> *CONFIG_BTDM_CONTROLLER_PINNED_TO_CORE_CHOICE*
> 
> *CONFIG_BLUEDROID_PINNED_TO_CORE_CHOICE*
> 
> *CONFIG_TCPIP_TASK_AFFINITY*
> 
> *CONFIG_ESP32_WIFI_TASK_CORE_ID*
>

Эта функция может вызываться как с процессоров PRO, так и с процессоров APP. После успешного перезапуска причиной сброса процессора будет SW_CPU_RESET. Периферийные устройства (за исключением Wi-Fi, BT, UART0, SPI1 и устаревших таймеров) не сбрасываются. Значение функцией не возвращается.

[esp_reset_reason_t esp_reset_reason(void)]()

Получить причину последнего сброса. Возвращается ***esp_reset_reason_t***:

```
enumerator ESP_RST_UNKNOWN
Невозможно определить причину сброса.

enumerator ESP_RST_POWERON
Сброс из-за события включения питания.

enumerator ESP_RST_EXT
Сброс с помощью внешнего PIN-кода (не применимо для ESP32)

enumerator ESP_RST_SW
Сброс программного обеспечения через esp_restart.

enumerator ESP_RST_PANIC
Сброс программного обеспечения из-за исключения / паники.

enumerator ESP_RST_INT_WDT
Сброс (программный или аппаратный) из-за сторожевого таймера прерывания.

enumerator ESP_RST_TASK_WDT
Сброс из-за диспетчера задач.

enumerator ESP_RST_WDT
Сброс из-за других сторожевых псов.

enumerator ESP_RST_DEEPSLEEP
Сброс после выхода из режима глубокого сна.

enumerator ESP_RST_BROWNOUT
Сброс отключения (программный или аппаратный)

enumerator ESP_RST_SDIO
Сброс через SDIO.

enumerator ESP_RST_USB
Сброс с помощью периферийного устройства USB.

enumerator ESP_RST_JTAG
Сброс с помощью JTAG.

enumerator ESP_RST_EFUSE
Сброс из-за ошибки efuse.

enumerator ESP_RST_PWR_GLITCH
Сброс из-за обнаруженного сбоя питания.

enumerator ESP_RST_CPU_LOCKUP
Сброс из-за блокировки процессора.

```





esp_err_t esp_register_shutdown_handler(shutdown_handler_t handle)
Register shutdown handler.

This function allows you to register a handler that gets invoked before the application is restarted using esp_restart function.

Parameters
handle -- function to execute on restart

Returns
ESP_OK on success

ESP_ERR_INVALID_STATE if the handler has already been registered

ESP_ERR_NO_MEM if no more shutdown handler slots are available

esp_err_t esp_unregister_shutdown_handler(shutdown_handler_t handle)
Unregister shutdown handler.

This function allows you to unregister a handler which was previously registered using esp_register_shutdown_handler function.

ESP_OK on success

ESP_ERR_INVALID_STATE if the given handler hasn't been registered before

---


---


### [Распределение памяти в ESP32](https://kotyara12.ru/iot/esp32_memory/)

Приложения ESP32 используют общие шаблоны компьютерной архитектуры:

***стек*** – динамическая память, автоматически выделяемая потоком управления программой,

***heap или куча*** – динамическая память, выделяемая вызовами функций malloc и calloc,

***статическая память*** – память, выделяемая под переменные во время компиляции.

При этом сам микроконтроллер ESP32 имеет на борту несколько типов оперативной памяти ( RAM ):

***DRAM (ОЗУ данных)*** — это память, которая подключена к шине данных ЦП и используется для хранения данных. Это наиболее распространенный вид памяти, доступ к которому осуществляется в виде кучи и стека. При запуске куча DRAM содержит всю память данных, которая не выделена приложением статически. Уменьшение статически выделяемых буферов увеличивает объем доступной свободной кучи и наоборот.

***IRAM (ОЗУ инструкций)*** — это память, которая подключена к шине инструкций ЦП и обычно содержит только исполняемые данные (т. е. инструкции, или скомпилированная программа). Важно понимать: в этой части оперативной памяти находится не вся ваша программа, а только отдельные функции, помещенные атрибутом IRAM_ATTR, а весь остальной код находится во flash-памяти и вызывается прямо оттуда. Однако её в некоторых случаях можно использовать и в качестве обычной памяти. Если доступ к IRAM осуществляется как доступ к общей памяти, все обращения должны быть в  32-битных единицах. 

D/IRAM — это ОЗУ, которое подключено к шине данных ЦП и шине инструкций, поэтому может использоваться как ОЗУ инструкций, так и ОЗУ данных. 
Также к ESP32 можно подключить внешнюю SPI RAM. Внешняя оперативная память интегрирована в карту памяти ESP32 через кеш в DRAM, и доступ к ней осуществляется аналогично DRAM. Такая память установлена в модулях серии ESP32-WROVER и на плате ESP32-CAM.

### [Miscellaneous System APIs](https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/misc_system_api.html#_CPPv411esp_restartv)

### [ICMP Echo](https://docs.espressif.com/projects/esp-idf/en/v5.0/esp32/api-reference/protocols/icmp_echo.html)

### [ESP32Ping](https://github.com/marian-craciunescu/ESP32Ping)




