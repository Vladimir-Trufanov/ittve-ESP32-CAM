/** Arduino-Esp32-CAM                               *** QueueHandlMulti.ino ***
 * 
 *                        Пример передачи сообщения из задачи и из прерывания с
 *                                                     приемом в основном цикле
 * 
 * v2.1, 03.12.2024                                   Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 21.11.2024
**/

#include "QueMessage.h"    // заголовочный файл класса TQueMessage 
TQueMessage queMessa;      // объект работы с сообщениями через очередь
unsigned long nLoop=0UL;   // счётчик циклов задачи отправки сообщений 

// Подключаем файлы обеспечения передачи и приёма сообщений через очередь 
//#include "QueMessage.hpp"       // общий реестр сообщений
//#include "QueueHandlMulti.hpp"  // сообщения примера по обработке очередей
#include "CommonMessage.h"
#include "QHM_Message.h"

// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;
// Выделяем и инициируем переменную для прошлого момента времени
int lastMillis = millis(); 

void ARDUINO_ISR_ATTR onTimer() 
{
   // Размещаем структуру для сообщения в статической памяти для того,
   // чтобы уменьшить фрагментацию кучи 
   // static DRAM_ATTR struct AMessage xiMessage;
   // Выделяем переменную планировщикe задач FreeRTOS для указания
   // необходимости переключения после прерывания на более приоритетную 
   // задачу, связанную с очередью
   static DRAM_ATTR BaseType_t xHigherPriorityTaskWoken;
   // Выделяем переменную для текущего момента времени
   static DRAM_ATTR int currMillis;
   // Выделяем переменную для прошедшего времени с начала запуска приложения
   static DRAM_ATTR int timeMillis;
   
   int i=15;
   
   /* 
   // Если в очереди есть место, будем размещать сообщение
   if (xQueue!=0)
   {
      // Сбрасываем признак переключения на более приоритетную задачу
      // после прерывания 
      xHigherPriorityTaskWoken = pdFALSE;
      // Определяем время, прошедшее с начала запуска приложения
      currMillis = millis(); 
      if (currMillis < lastMillis) lastMillis=0;
      timeMillis=currMillis-lastMillis;
      // Формируем сообщение для передачи в очередь
      sprintf(xiMessage.ucData, "Прошло %d миллисекунд",timeMillis);
      xiMessage.ucSize = 0;
      while (xiMessage.ucData[xiMessage.ucSize]>0) 
      {
         xiMessage.ucSize++;
      }
      // Отправляем сообщение в структуре AMessage 
      if (xQueueSendFromISR(xQueue, &xiMessage, &xHigherPriorityTaskWoken) != pdPASS)
      {
         Serial.println("ISR: Не удалось отправить структуру!");
      }
   }
   else 
   {
      Serial.println("ISR: Очередь для структур не создана!");
   }
   // Если требуется отдать управление планировщику на переключение 
   // после прерывания на более приоритетную задачу, делаем это 
   if (xHigherPriorityTaskWoken)
   {
      Serial.println("ISR: Управление передаётся планировщику!");
      portYIELD_FROM_ISR();
   }
   */
}
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   Serial.begin(115200);
   bool bRet=queMessa.Create();
   if (!bRet) Serial.println("SETUP: Очередь не была создана и не может использоваться!");
   else Serial.println("SETUP: Очередь сформирована!");

   //char tBuffer[128];
   //messISR(tBuffer,7,"fmess32","smess32"); 

   // Определяем дополнительную задачу по отправке сообщений
   xTaskCreatePinnedToCore (
      vATask,               // название функции, которая будет запускаться, как параллельная задача
      "Отправка из задачи", // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      10,                   // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Определяем общую задачу приёма сообщений
   xTaskCreatePinnedToCore (
      vReceiveMess,         // название функции, которая будет запускаться, как параллельная задача
      "Приём сообщений",    // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      9,                    // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 1 секунда (1000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 1400000, true, 0);
}
// ****************************************************************************
// *           Выполнять ПЕРЕДАЧУ СООБЩЕНИЯ ИЗ ЗАДАЧИ в бесконечном цикле     *
//  (если задача завершится - не будет циклится, то контроллер перезагрузится)
// ****************************************************************************
void vATask (void *pvParameters) 
{
   // Привязываем структуру для для отправки сообщения 
   struct tStruMessage taskStruMess;
   // Готовим цикл задачи
   while (1) 
   {
      nLoop++;
      // Отправляем информационное сообщение "Передано %s сообщение из задачи"
      //bool bRet=queMessa.Send();
      bool bRet=queMessa.Send(taskStruMess,tmt_NOTICE,tmk_QHM,tqhm_SendFromTask,nLoop);
      Serial.println("vATask: Сообщение отправлено!");
      delay (1601); 
   }
}
// ****************************************************************************
// *             Обеспечить приём всех сообщений и передачу их                *
// *                          в последовательный порт                         *
// ****************************************************************************
void vReceiveMess (void *pvParameters) 
{
   // Привязываем структуру для для приема сообщения 
   struct tStruMessage ReceiveStruMess;
   String c=EmptyMessage;
   // Готовим цикл задачи
   while (1) 
   {
      // ReceiveMess(tQueue, ReceiveStruMess, MessFormat);  
      queMessa.Receive();
      delay (1303); 
   }
}
// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   int i=7;
   delay(905);
}

// **************************************************** QueueHandlMulti.ino ***
