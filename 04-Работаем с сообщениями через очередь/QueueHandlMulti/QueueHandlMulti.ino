/** Arduino-Esp32-CAM                               *** QueueHandlMulti.ino ***
 * 
 *                        Пример передачи сообщения из задачи и из прерывания с
 *                                                     приемом в основном цикле
 * 
 * v3.2.1, 11.12.2024                                 Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 21.11.2024
**/

// ============================================= 1. Инициирование использования очереди ===
// Подключаем файлы обеспечения передачи и приёма сообщений через очередь                //
#include "QueMessage.h"     // заголовочный файл класса TQueMessage                      //
#include "CommonMessage.h"  // общий реестр сообщений                                    //
#include "QHM_Message.h"    // сообщения приложения (примера по обработке очередей)      //
                                                                                         //
// Готовим для прикрепления свою функцию - передатчик сообщения в последовательный порт  //
// вместо установленного в классе передатчика по умолчанию "transmess"                   //
void transmess2(char *mess, char *prefix="")                                             //
{                                                                                        //
   // Выводим массивы символов с 0-вым окончанием                                        //
   Serial.print(prefix);  // передали префикс                                            //
   Serial.println(mess);  // передали сообщение                                          //
}                                                                                        //                                                                      
                                                                                         //
// Определяем формат сообщения                                                           //
int MessFormat=tfm_FULL;                                                                 //
                                                                                         //
// Определяем источник сообщений                                                         //
#define tmk_APP "QHM"       // пример по обработке очередей                              //
// Назначаем объект работы с сообщениями через очередь                                   //
TQueMessage queMessa;                                                                    //
// ========================================================================================                                                                                         

// Выделяем счётчик циклов задачи отправки сообщений       
unsigned long nLoop=0UL;     
// Перечисляем режимы приема сообщений (Message reception modes)
typedef enum {
   tmr_ONEATIME,        // 0 по одному               - one at a time
   tmr_QUEUERELEASE,    // 1 до освобождения очереди - before the queue is released
} tModeReceive;
// Задаём текущий режим приема сообщений
int t_ModeReceive=tmr_QUEUERELEASE;

// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;
// Выделяем и инициируем переменную для прошлого момента времени
int lastMillis = millis(); 

void ARDUINO_ISR_ATTR onTimer() 
{
   // Размещаем переменные времени для сообщений в статической памяти 
   // для того, чтобы уменьшить фрагментацию кучи
   static DRAM_ATTR int currMillis;  // переменная для текущего момента времени
   static DRAM_ATTR int timeMillis;  // для прошедшего времени с начала запуска приложения

   // Определяем время, прошедшее с начала запуска приложения
   currMillis = millis(); 
   if (currMillis < lastMillis) lastMillis=0;
   timeMillis=currMillis-lastMillis;

   // Отправляем информационное сообщение "Прошло %d миллисекунд"
   String inMess=queMessa.SendISR(tmt_NOTICE,tmk_APP,ItsBeenMS,timeMillis);
   // Если невозможно отправить сообщение, то сообщаем
   if (inMess!=isOk) Serial.println(inMess); 
}
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   // Готовим последовательный порт для сообщений
   Serial.begin(115200);
   while (!Serial) continue;
   Serial.println("Последовательный порт работает!");

   // =================================== 2. Создание очереди и подключение передатчика ===
   // Создаем очередь                                                                    //
   String inMess=queMessa.Create();                                                      //
   // Если очередь получилась, то отмечаем  "Очередь сформирована"                       //
   if (inMess==isOk) Serial.println(tQueueBeformed);                                     //
   // Если не получилось, сообщаем "Очередь не была создана и не может использоваться"   //
   else Serial.println(tQueueNotCreate);                                                 //
   // Прикрепляем функцию - передатчик сообщения в последовательный порт                 //
   queMessa.attachFunction(transmess2);                                                  //
   // ===================================================================================== 

   // Определяем дополнительную задачу по отправке сообщений
   xTaskCreatePinnedToCore (
      vATask,               // название функции, которая будет запускаться, как параллельная задача
      "Отправка из задачи", // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      10,                   // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Определяем общую задачу приёма сообщений
   xTaskCreatePinnedToCore (
      vReceiveMess,         // название функции, которая будет запускаться, как параллельная задача
      "Приём сообщений",    // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      9,                    // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - почти 1 секунда (997000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 997000, true, 0);
}
// ****************************************************************************
// *           Выполнять ПЕРЕДАЧУ СООБЩЕНИЯ ИЗ ЗАДАЧИ в бесконечном цикле     *
//  (если задача завершится - не будет циклится, то контроллер перезагрузится)
// ****************************************************************************
void vATask (void *pvParameters) 
{
   // Готовим цикл задачи
   while (1) 
   {
      nLoop++;
      // Отправляем информационное сообщение "Передано %s сообщение из задачи"
      String inMess=queMessa.Send(tmt_NOTICE,tmk_APP,SendFromTask,nLoop);
      // Если невозможно отправить сообщение, то сообщаем
      if (inMess!=isOk) Serial.println(inMess); 
      vTaskDelay(1301/portTICK_PERIOD_MS);
   }
}
// ****************************************************************************
// *             Обеспечить приём всех сообщений и передачу их                *
// *                          в последовательный порт                         *
// ****************************************************************************
void vReceiveMess (void *pvParameters) 
{
   // Определяем переменную для числа сообщений, ожидающих выгрузку из очереди 
   int iwait;
   // Готовим цикл задачи
   while (1) 
   {
      // Если требуется выбрать все сообщения из очереди
      if (t_ModeReceive==tmr_QUEUERELEASE)
      {
         iwait=queMessa.How_many_wait();
         while(iwait>0)
         {
            // Выбираем из очереди и отправляем сообщение на периферию
            // с префиксом "Hello ";
            queMessa.Post(queMessa.Receive(MessFormat),"Hello ");
            vTaskDelay(100/portTICK_PERIOD_MS);
            iwait=queMessa.How_many_wait();
         }
      }
      // Иначе выбираем одно сообщение
      else
      {
         iwait=queMessa.How_many_wait();
         if (iwait>0) 
         {
            // Выбираем из очереди и отправляем сообщение на периферию
            queMessa.Post(queMessa.Receive(MessFormat));
         }
      }
      vTaskDelay(503/portTICK_PERIOD_MS);
   }
}

// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   int i=7;
   delay(2905);
}

// **************************************************** QueueHandlMulti.ino ***
