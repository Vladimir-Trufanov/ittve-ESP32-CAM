/** Arduino-Esp32-CAM                               *** QueueHandlMulti.ino ***
 * 
 *                        Пример передачи сообщения из задачи и из прерывания с
 *                                                     приемом в основном цикле
 * 
 * v3.2.1, 11.12.2024                                 Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 21.11.2024
**/

// Подключаем файлы обеспечения передачи и приёма сообщений через очередь 
#include "QueMessage.h"     // заголовочный файл класса TQueMessage 
#include "QHM_Message.h"    // сообщения приложения (примера по обработке очередей)
// Определяем формат сообщения
int MessFormat=tfm_FULL;
// Определяем источник сообщений  
#define tmk_APP "QHM"       // пример по обработке очередей
// Назначаем объект работы с сообщениями через очередь
TQueMessage queMessa;
// Выделяем счётчик циклов задачи отправки сообщений       
unsigned long nLoop=0UL;     

// Перечисляем режимы приема сообщений (Message reception modes)
//typedef enum {
//   tmr_ONEATIME,        // 0 по одному               - one at a time
//   tmr_QUEUERELEASE,    // 1 до освобождения очереди - before the queue is released
//} tModeReceive;
// Задаём текущий режим приема сообщений
//int t_ModeReceive=tmr_ONEATIME;

// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;
// Выделяем и инициируем переменную для прошлого момента времени
int lastMillis = millis(); 

void ARDUINO_ISR_ATTR onTimer() 
{
   // Размещаем переменные времени для сообщений в статической памяти 
   // для того, чтобы уменьшить фрагментацию кучи
   static DRAM_ATTR int currMillis;  // переменная для текущего момента времени
   static DRAM_ATTR int timeMillis;  // для прошедшего времени с начала запуска приложения

   // Определяем время, прошедшее с начала запуска приложения
   currMillis = millis(); 
   if (currMillis < lastMillis) lastMillis=0;
   timeMillis=currMillis-lastMillis;

   // Отправляем информационное сообщение "Прошло %d миллисекунд"
   String inMess=queMessa.SendISR(tmt_NOTICE,tmk_APP,ItsBeenMS,timeMillis);
   // Если невозможно отправить сообщение, то сообщаем
   if (inMess!=EmptyMessage) Serial.println(inMess); 
}
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   // Готовим последовательный порт для сообщений
   Serial.begin(115200);
   while (!Serial) continue;
   Serial.println("Последовательный порт работает!");
   // Создаем очередь
   String inMess="";
   inMess=queMessa.Create();
   // Если не получилось, сообщаем "Очередь не была создана и не может использоваться" 
   if (inMess==QueueNotCreate) Serial.println(QueueNotCreate);
   // Если очередь получилась, то отмечаем  "Очередь сформирована" 
   else Serial.println(QueueBeformed);
   // Подключаем функцию передачи сообщения на периферию - transmess
   // (функция может быть заменена на любую другую,
   // но с соответствующим контекстом входящих параметров)
   queMessa.attachFunction(transmess);

   // Определяем дополнительную задачу по отправке сообщений
   xTaskCreatePinnedToCore (
      vSendMess,            // название функции, которая будет запускаться, как параллельная задача
      "Отправка из задачи", // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      5,                    // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Определяем общую задачу приёма сообщений
   xTaskCreatePinnedToCore (
      vReceiveMess,         // название функции, которая будет запускаться, как параллельная задача
      "Приём сообщений",    // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      10,                   // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 2 секунды (2000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 2000000, true, 0);
}
// ****************************************************************************
// *           Выполнять ПЕРЕДАЧУ СООБЩЕНИЯ ИЗ ЗАДАЧИ в бесконечном цикле     *
//  (если задача завершится - не будет циклится, то контроллер перезагрузится)
// ****************************************************************************
void vSendMess (void *pvParameters) 
{
   // Готовим цикл задачи
   while (1) 
   {
      nLoop++;
      // Отправляем информационное сообщение "Передано %s сообщение из задачи"
      String inMess=queMessa.Send(tmt_NOTICE,tmk_APP,SendFromTask,nLoop);
      // Если невозможно отправить сообщение, то сообщаем
      if (inMess!=EmptyMessage) Serial.println(inMess); 
      //Serial.print("vSendMess: "); Serial.println(uxTaskPriorityGet(NULL)); 
      vTaskDelay(1900/portTICK_PERIOD_MS);
   }
}
// ****************************************************************************
// *             Обеспечить приём всех сообщений и передачу их                *
// *                          в последовательный порт                         *
// ****************************************************************************
void vReceiveMess (void *pvParameters) 
{
   // Определяем переменную для числа сообщений, ожидающих выгрузку из очереди 
   int iwait;
   // Готовим цикл задачи
   while (1) 
   {
      /*
      // Если требуется выбрать все сообщения из очереди
      if (t_ModeReceive==tmr_QUEUERELEASE)
      {
         iwait=queMessa.How_many_wait();
         while(iwait>0)
         {
            // Выбираем из очереди и отправляем сообщение на периферию
            queMessa.Post(queMessa.Receive(MessFormat));
            vTaskDelay(100/portTICK_PERIOD_MS);
            iwait=queMessa.How_many_wait();
         }
      }
      // Иначе выбираем одно сообщение
      else
      {
      */
         //iwait=queMessa.How_many_wait();
         //if (iwait>0) 
         //{
            // Выбираем из очереди и отправляем сообщение на периферию
            //queMessa.Post(queMessa.Receive(MessFormat));
         //}
      //}
      
      // Выбираем из очереди и отправляем сообщение на периферию
      queMessa.Post(queMessa.Receive(MessFormat));
      vTaskDelay(500/portTICK_PERIOD_MS);
   }
}

// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   //Serial.print("Loop: "); Serial.println(uxTaskPriorityGet(NULL)); 
   delay(2100);
}

// **************************************************** QueueHandlMulti.ino ***
