/** Arduino-Esp32-CAM                              *** QueueHandlMulti2.ino ***
 * 
 *                        Пример передачи сообщения из задачи и из прерывания с
 *                                                     приемом в основном цикле
 * 
 * v1.1, 29.11.2024                                   Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 21.11.2024
**/

#include "QueMessa.h"    

// Создаем структуру для передачи сообщения из задачи и указатель на нее   
struct AMessage xMessage, *pxMessage;
// Создаем структуру для приёма сообщений   
struct AMessage xRxedStructure;
// Определяем очередь сообщений
QueueHandle_t xQueue;
// Инициируем счетчик циклов дополнительной задачи
unsigned long nLoop = 0UL;
// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;
// Выделяем и инициируем переменную для прошлого момента времени
int lastMillis = millis(); 

void ARDUINO_ISR_ATTR onTimer() 
{
   // Размещаем структуру для сообщения в статической памяти для того,
   // чтобы уменьшить фрагментацию кучи 
   static DRAM_ATTR struct AMessage xiMessage;
   // Выделяем переменную планировщикe задач FreeRTOS для указания
   // необходимости переключения после прерывания на более приоритетную 
   // задачу, связанную с очередью
   static DRAM_ATTR BaseType_t xHigherPriorityTaskWoken;
   // Выделяем переменную для текущего момента времени
   static DRAM_ATTR int currMillis;
   // Выделяем переменную для прошедшего времени с начала запуска приложения
   static DRAM_ATTR int timeMillis;
    
   // Если в очереди есть место, будем размещать сообщение
   if (xQueue!=0)
   {
      // Сбрасываем признак переключения на более приоритетную задачу
      // после прерывания 
      xHigherPriorityTaskWoken = pdFALSE;
      // Определяем время, прошедшее с начала запуска приложения
      currMillis = millis(); 
      if (currMillis < lastMillis) lastMillis=0;
      timeMillis=currMillis-lastMillis;
      // Формируем сообщение для передачи в очередь
      sprintf(xiMessage.ucData, "Прошло %d миллисекунд",timeMillis);
      xiMessage.ucSize = 0;
      while (xiMessage.ucData[xiMessage.ucSize]>0) 
      {
         xiMessage.ucSize++;
      }
      // Отправляем сообщение в структуре AMessage 
      if (xQueueSendFromISR(xQueue, &xiMessage, &xHigherPriorityTaskWoken) != pdPASS)
      {
         Serial.println("ISR: Не удалось отправить структуру!");
      }
   }
   else 
   {
      Serial.println("ISR: Очередь для структур не создана!");
   }
   // Если требуется отдать управление планировщику на переключение 
   // после прерывания на более приоритетную задачу, делаем это 
   if (xHigherPriorityTaskWoken)
   {
      Serial.println("ISR: Управление передаётся планировщику!");
      portYIELD_FROM_ISR();
   }
}
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   Serial.begin(115200);

   // Определяем дополнительную задачу
   xTaskCreatePinnedToCore (
      vATask,         // название функции, которая будет запускаться, как параллельная задача
      "Сообщение",    // название задачи
      1024,           // размер стека в байтах
      NULL,           // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      0,              // приоритет задачи
      NULL,           // дескриптор или указатель на задачу
      0               // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 1 секунда (1000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 1400000, true, 0);
   // Создаем очередь из 10 структур
   xQueue = xQueueCreate(10, sizeof(struct AMessage));
   if(xQueue==NULL)
   {
      Serial.println("SETUP: Очередь не была создана и не может использоваться!");
   }
   Serial.println("SETUP: Очередь сформирована!");
}
// ****************************************************************************
// *           Выполнять ПЕРЕДАЧУ СООБЩЕНИЯ ИЗ ЗАДАЧИ в бесконечном цикле     *
//  (если задача завершится - не будет циклится, то контроллер перезагрузится)
// ****************************************************************************
void vATask (void* pvParameters) 
{
   while (1) 
   {
      nLoop++;
      if (xQueue!=0)
      {
         // Формируем сообщение для передачи в очередь
         sprintf(xMessage.ucData, "Передано %d сообщение из задачи", nLoop);
         xMessage.ucSize = 0;
         while (xMessage.ucData[xMessage.ucSize]>0) 
         {
            xMessage.ucSize++;
         }
         pxMessage = &xMessage;
         if (xQueueSend(xQueue,pxMessage,5) != pdPASS)
         {
            Serial.println("TASK: Не удалось отправить структуру даже после 5 тиков!");
         }
      }
      else 
      {
         Serial.println("TASK: Очередь для структур не создана!");
      }
      delay (1600); 
   }
}
// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   if (xQueue != NULL)
   {
      // Получаем сообщение из созданной очереди для хранения сложного
      // структурного сообщения. Блокировка на 10 тиков, если сообщение
      // недоступно немедленно. Значение считывается в структурную
      // переменную AMessage, поэтому после вызова xQueueReceive()  
      // xRxedStructure будет содержать копию сообщения
      if (xQueueReceive(xQueue,&xRxedStructure,10) != pdPASS)
      {
         Serial.println("LOOP: Не удалось принять структуру даже после 10 тиков!");
      }
      else
      {
         Serial.print(xRxedStructure.ucSize);
         Serial.print(": ");
         Serial.println(xRxedStructure.ucData);
      }
   }
   else
   {
      Serial.println("LOOP: Нет очереди!");
   }
   delay(1300);
}

// *************************************************** QueueHandlMulti2.ino ***
