/** Arduino-Esp32-CAM                               *** QueueHandlMulti.ino ***
 * 
 *                        Пример передачи сообщения из задачи и из прерывания с
 *                                                     приемом в основном цикле
 * 
 * v3.2.6, 21.12.2024                                 Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 21.11.2024
**/

// Порядок работы приложения:
// - основной цикл имеет самый низкий приоритет и перезапускается с интервалом
//   2100 миллисекунд. В основном цикле отправляется в очередь длинное сообщение, 
//   которое обрезается до 255 символов с завершающим нулем;
// - прерывание перезапускается с интервалом в 2000 миллисекунд и отправляет 
//   "сообщение с первым уточнением целого типа" - номером сообщения из прерывания;
// - задача vSendMess имеет приоритет 5, перезапускается с интервалом 1900 миллисекунд
//   и отправляет "сообщение с двумя уточнениями целого типа" - номером сообщения
//   из задачи и прошедшим числом миллисекунд с начала загрузки приложения;
// - задача vReceiveMess имеет приоритет 10, перезапускается с интервалом в 500 
//   миллисекунд и принимает сообщения (выбирает из очереди) одним из двух
//   способов: либо "одно сообщение за раз", либо "все сообщения до опустошения 
//   очереди".
// 

// Режимы демонстрации приложения:
//#define tmr_ONEATIME        // по одному               
#define tmr_QUEUERELEASE      // до освобождения очереди 
//#define tmr_SHOWQUEUESIZE   // показывать размер очереди до и после приёма сообщения
//#define tmr_TASKPRIORITY    // показывать текущие приоритеты задач
//#define tmr_TRACEMEMORY     // трассировать память контроллера

// ============================================== 1. Инициировать использование очереди ===
// Подключаем файлы обеспечения передачи и приёма сообщений через очередь                //
#include "QHM_Message.h"    // сообщения приложения (примера по обработке очередей)      //
#include <QueMessage.h>     // заголовочный файл класса TQueMessage                      //
// Готовим для прикрепления свою функцию - передатчик сообщения в последовательный порт  //
// вместо установленного в классе передатчика по умолчанию "transmess"                   //
void transmess2(char *mess, char *prefix="")                                             //
{                                                                                        //
   // Выводим массивы символов с 0-вым окончанием                                        //
   Serial.print(prefix);  // передали префикс                                            //
   Serial.println(mess);  // передали сообщение                                          //
}                                                                                        //                                                                      
// Назначаем объект работы с сообщениями через очередь                                   //
TQueMessage queMessa(amessAPP,SizeMess,tmk_APP);                                                           //
// ========================================================================================                                                                                         

// Выделяем счётчик циклов задачи отправки сообщений       
unsigned long nLoop=0UL;  
// Выделяем и инициируем переменную для прошлого момента времени
unsigned long lastMillis = millis(); 
// Выделяем счётчик прерываний       
unsigned long nLoopISR=0UL;  

// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;

// ****************************************************************************
// *                    Отправлять сообщения из прерывания                    *
// ****************************************************************************
void ARDUINO_ISR_ATTR onTimer() 
{
   // Отправляем информационное сообщение "Передано %s сообщение из прерывания"
   nLoopISR++;
   String inMess=queMessa.SendISR(tmt_NOTICE,SendFromISR,nLoopISR,"ISR");
   // Если невозможно отправить сообщение, то сообщаем
   if (inMess!=isOk) Serial.println(inMess); 

   #ifdef tmr_TASKPRIORITY
       Serial.print("ISR: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
}
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   // Готовим последовательный порт для сообщений
   Serial.begin(115200);
   while (!Serial) continue;
   Serial.println("Последовательный порт работает!");

   // ====================================== 2. Создать очередь и подключить передатчик ===
   // Создаем очередь                                                                    //
   String inMess=queMessa.Create();                                                      //
   // Если не получилось, сообщаем "Очередь не была создана и не может использоваться"   // 
   if (inMess==QueueNotCreate) Serial.println(QueueNotCreate);                           //
   // Если очередь получилась, то отмечаем  "Очередь сформирована"                       //
   else Serial.println(QueueBeformed);                                                   //
   // Подключаем функцию передачи сообщения на периферию                                 //
   queMessa.attachFunction(transmess2);                                                  //
   // ===================================================================================== 

   // Определяем дополнительную задачу по отправке сообщений
   xTaskCreatePinnedToCore (
      vSendMess,            // название функции, которая будет запускаться, как параллельная задача
      "Отправка из задачи", // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      5,                    // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Определяем общую задачу приёма сообщений
   xTaskCreatePinnedToCore (
      vReceiveMess,         // название функции, которая будет запускаться, как параллельная задача
      "Приём сообщений",    // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      10,                   // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 2 секунды (2000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 2000000, true, 0);

   #ifdef tmr_TASKPRIORITY
      Serial.print("Setup: "); Serial.println(uxTaskPriorityGet(NULL));     
      Serial.print("Max:   "); Serial.println(configMAX_PRIORITIES);     
   #endif
}
// ****************************************************************************
// *         Выполнять ПЕРЕДАЧУ СООБЩЕНИЯ о количестве запусков задачи и      *
// *               о прошедшем времени с начала запуска приложения            *
// ****************************************************************************
void vSendMess (void *pvParameters) 
{
   // Размещаем переменные времени для сообщений в статической памяти 
   // для того, чтобы уменьшить фрагментацию кучи
   static DRAM_ATTR unsigned long currMillis;  // переменная для текущего момента времени
   static DRAM_ATTR unsigned long timeMillis;  // для прошедшего времени с начала запуска приложения

   #ifdef tmr_TASKPRIORITY
       Serial.print("vSendMess: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
   // Готовим цикл задачи
   while (1) 
   {
      // Если разрешено, трассируем память контроллера
      #ifdef tmr_TRACEMEMORY
         // Получаем полный размер кучи в памяти
         printf("Общий размер ВСТРОЕННОЙ памяти:     %u\n", ESP.getHeapSize());
         // Количество доступной кучи в памяти
         printf("Оставшаяся доступная память в куче: %u\n", ESP.getFreeHeap());
         // Самый низкий уровень свободной кучи с момента загрузки
         printf("Минимальная свободная с загрузки:   %u\n", ESP.getMinFreeHeap());
         // Размер общей кучи SPI PSRAM
         printf("Общий размер SPI PSRAM:             %u\n", ESP.getPsramSize());
         // Количество свободной PSRAM
         printf("Количество свободной PSRAM:         %d\n", ESP.getFreePsram());
         // Минимальный размер свободной памяти в SPI RAM
         printf("Минимум свободной SPI PSRAM:        %d\n", ESP.getMinFreePsram());
         // Размер самого большого блока PSRAM, который может быть выделен
         printf("Самый большой блок для выделения:   %d\n", ESP.getMaxAllocPsram());
      #endif

      // Изменяем счетчик перезапусков
      nLoop++;
      // Определяем время, прошедшее с начала запуска приложения
      currMillis = millis(); 
      if (currMillis < lastMillis) lastMillis=0;
      timeMillis=currMillis-lastMillis;
      // Отправляем информационное сообщение  "Передано %s сообщение из задачи на %s миллисекунде")
      String inMess=queMessa.Send(tmt_NOTICE,SendFromTask,nLoop,timeMillis);
      if (inMess!=isOk) Serial.println(inMess); 
      vTaskDelay(1900/portTICK_PERIOD_MS);
   }
}
// ****************************************************************************
// *             Обеспечить приём всех сообщений и передачу их                *
// *                 в последовательный порт (на периферию)                   *
// ****************************************************************************
void vReceiveMess (void *pvParameters) 
{
   #ifdef tmr_TASKPRIORITY
      Serial.print("vReceiveMess: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
   // Готовим цикл задачи
   while (1) 
   {
      #ifdef tmr_SHOWQUEUESIZE
         Serial.print("   До "); Serial.println(queMessa.How_many_wait());     
      #endif

      // Выбираем из очереди и отправляем сообщение на периферию
      #ifdef tmr_QUEUERELEASE
         queMessa.PostAll();
      #else
         queMessa.Post(tfm_NOTIME,"Hello: ");
      #endif

      #ifdef tmr_SHOWQUEUESIZE
         Serial.print("После "); Serial.println(queMessa.How_many_wait());     
      #endif
      vTaskDelay(500/portTICK_PERIOD_MS);
   }
}

// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   #ifdef tmr_TASKPRIORITY
      Serial.print("Loop: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
   delay(2100);
   // Отправляем информационное сообщение  "Передано %s сообщение из задачи на %s миллисекунде")
   String inMess=queMessa.Send(tmt_NOTICE,SendLongMess);
   if (inMess!=isOk) Serial.println(inMess); 
}

// **************************************************** QueueHandlMulti.ino ***
