/** Arduino-Esp32-CAM                               *** QueueHandlMulti.ino ***
 * 
 *                        Пример передачи сообщения из задачи и из прерывания с
 *                                                     приемом в основном цикле
 * 
 * v3.2.3, 18.12.2024                                 Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 21.11.2024
**/

// Порядок работы приложения:
// - основной цикл имеет самый низкий приоритет и перезапускается с интервалом
//   2100 миллисекунд. В основном цикле отправляется в очередь длинное сообщение, 
//   которое обрезается до 255 символов с завершающим нулем;
// - прерывание перезапускается с интервалом в 2000 миллисекунд и отправляет 
//   "сообщение с первым уточнением целого типа" - номером сообщения из прерывания;
// - задача vSendMess имеет приоритет 5, перезапускается с интервалом 1900 миллисекунд
//   и отправляет "сообщение с двумя уточнениями целого типа" - номером сообщения
//   из задачи и прошедшим числом миллисекунд с начала загрузки приложения;
// - задача vReceiveMess имеет приоритет 10, перезапускается с интервалом в 500 
//   миллисекунд и принимает сообщения (выбирает из очереди) одним из двух
//   способов: либо "одно сообщение за раз", либо "все сообщения до опустошения 
//   очереди".
// 

// Режимы демонстрации приложения:
//#define tmr_ONEATIME        // по одному               
//#define tmr_QUEUERELEASE    // до освобождения очереди 
//#define tmr_SHOWQUEUESIZE   // показывать размер очереди до и после приёма сообщения
//#define tmr_TASKPRIORITY    // показывать текущие приоритеты задач

// Подключаем файлы обеспечения передачи и приёма сообщений через очередь 
#include "QueMessage.h"     // заголовочный файл класса TQueMessage 
#include "QHM_Message.h"    // сообщения приложения (примера по обработке очередей)
// Определяем формат сообщения
int MessFormat=tfm_FULL;
// Определяем источник сообщений  
#define tmk_APP "QHM"       // пример по обработке очередей
// Назначаем объект работы с сообщениями через очередь
TQueMessage queMessa;
// Выделяем счётчик циклов задачи отправки сообщений       
unsigned long nLoop=0UL;  

// ****************************************************************************
// *  Сформировать сообщение о прошедшем времени с начала запуска приложения  *
// *                        И ПЕРЕДАТЬ ЧЕРЕЗ ПРЕРЫВАНИЕ                       *
// ****************************************************************************
// Определяем заголовок для объекта таймера
hw_timer_t *timer = NULL;
// Выделяем и инициируем переменную для прошлого момента времени
int lastMillis = millis(); 

void ARDUINO_ISR_ATTR onTimer() 
{
   // Размещаем переменные времени для сообщений в статической памяти 
   // для того, чтобы уменьшить фрагментацию кучи
   static DRAM_ATTR int currMillis;  // переменная для текущего момента времени
   static DRAM_ATTR int timeMillis;  // для прошедшего времени с начала запуска приложения

   // Определяем время, прошедшее с начала запуска приложения
   currMillis = millis(); 
   if (currMillis < lastMillis) lastMillis=0;
   timeMillis=currMillis-lastMillis;

   // Отправляем информационное сообщение "Прошло %d миллисекунд"
   String inMess=queMessa.SendISR(tmt_NOTICE,tmk_APP,ItsBeenMS,timeMillis);
   // Если невозможно отправить сообщение, то сообщаем
   if (inMess!=EmptyMessage) Serial.println(inMess); 

   #ifdef tmr_TASKPRIORITY
       Serial.print("ISR: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
}
// ****************************************************************************
// *                          Инициировать приложение                         *
// ****************************************************************************
void setup() 
{
   // Готовим последовательный порт для сообщений
   Serial.begin(115200);
   while (!Serial) continue;
   Serial.println("Последовательный порт работает!");

   // Создаем очередь
   String inMess="";
   inMess=queMessa.Create();
   // Если не получилось, сообщаем "Очередь не была создана и не может использоваться" 
   if (inMess==QueueNotCreate) Serial.println(QueueNotCreate);
   // Если очередь получилась, то отмечаем  "Очередь сформирована" 
   else Serial.println(QueueBeformed);
   // Подключаем функцию передачи сообщения на периферию - transmess
   // (функция может быть заменена на любую другую,
   // но с соответствующим контекстом входящих параметров)
   queMessa.attachFunction(transmess);

   // Определяем дополнительную задачу по отправке сообщений
   xTaskCreatePinnedToCore (
      vSendMess,            // название функции, которая будет запускаться, как параллельная задача
      "Отправка из задачи", // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      5,                    // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Определяем общую задачу приёма сообщений
   xTaskCreatePinnedToCore (
      vReceiveMess,         // название функции, которая будет запускаться, как параллельная задача
      "Приём сообщений",    // название задачи
      2048,                 // размер стека в байтах
      NULL,                 // указатель параметра, который будет передан задаче (NULL, если параметр не передаётся)
      10,                   // приоритет задачи
      NULL,                 // дескриптор или указатель на задачу
      1                     // ядро процессора, на котором требуется запустить задачу 
   );
   // Создаём объект таймера, устанавливаем его частоту отсчёта (1Mhz)
   timer = timerBegin(1000000);
   // Подключаем функцию обработчика прерывания от таймера - onTimer
   timerAttachInterrupt(timer, &onTimer);
   // Настраиваем таймер: интервал перезапуска - 2 секунды (2000000 микросекунд),
   // всегда повторяем перезапуск (третий параметр = true), неограниченное число 
   // раз (четвертый параметр = 0) 
   timerAlarm(timer, 2000000, true, 0);

   #ifdef tmr_TASKPRIORITY
      Serial.print("Setup: "); Serial.println(uxTaskPriorityGet(NULL));     
      Serial.print("Max:   "); Serial.println(configMAX_PRIORITIES);     
   #endif
}
// ****************************************************************************
// *           Выполнять ПЕРЕДАЧУ СООБЩЕНИЯ ИЗ ЗАДАЧИ в бесконечном цикле     *
//  (если задача завершится - не будет циклится, то контроллер перезагрузится)
// ****************************************************************************
void vSendMess (void *pvParameters) 
{
   #ifdef tmr_TASKPRIORITY
       Serial.print("vSendMess: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
   // Готовим цикл задачи
   while (1) 
   {
      nLoop++;
      // Отправляем информационное сообщение "Передано %s сообщение из задачи"
      String inMess=queMessa.Send(tmt_NOTICE,tmk_APP,SendFromTask,nLoop);
      // Если невозможно отправить сообщение, то сообщаем
      if (inMess!=EmptyMessage) Serial.println(inMess); 
      //Serial.print("vSendMess: "); Serial.println(uxTaskPriorityGet(NULL)); 
      vTaskDelay(1900/portTICK_PERIOD_MS);
   }
}
// ****************************************************************************
// *             Обеспечить приём всех сообщений и передачу их                *
// *                          в последовательный порт                         *
// ****************************************************************************
void vReceiveMess (void *pvParameters) 
{
   #ifdef tmr_TASKPRIORITY
      Serial.print("vReceiveMess: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
   // Готовим цикл задачи
   while (1) 
   {
      #ifdef tmr_SHOWQUEUESIZE
         Serial.print("   До "); Serial.println(queMessa.How_many_wait());     
      #endif

      // Выбираем из очереди и отправляем сообщение на периферию
      #ifdef tmr_QUEUERELEASE
         queMessa.PostAll();
      #else
         queMessa.Post(tfm_NOTIME,"Hello: ");
      #endif

      #ifdef tmr_SHOWQUEUESIZE
         Serial.print("После "); Serial.println(queMessa.How_many_wait());     
      #endif
      vTaskDelay(500/portTICK_PERIOD_MS);
   }
}

// ****************************************************************************
// *                    Выполнить основной цикл приложения                    *
// ****************************************************************************
void loop() 
{
   #ifdef tmr_TASKPRIORITY
      Serial.print("Loop: "); Serial.println(uxTaskPriorityGet(NULL));     
   #endif
   delay(2100);
}

// **************************************************** QueueHandlMulti.ino ***
