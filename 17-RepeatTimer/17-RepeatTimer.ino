/** Arduino C/C++ ************************************** 17-RepeatTimer.ino ***
 * 
 *     Показать примеры использования аппаратного таймера в ESP32. Здесь таймер
 *         запускает функцию обработки каждую секунду. Таймер можно остановить, 
 *                                            замкнув на землю 0 контакт (IO0).
 *                                            
 * https://docs.espressif.com/projects/arduino-esp32/en/latest/api/timer.html -
 *                                 документация Espressif по работе с таймерами
 * 
 * v1.1, 07.10.2024                                   Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 07.10.2024
**/

// Определяем нулевой пин (IO0)
#define BTN_STOP_ALARM 0
// Настраиваем указатель таймера с именем 'timer'
hw_timer_t *timer = NULL;
// Резервируем переменную семафора таймера для отслеживания
// срабатывания таймера в основном цикле (loop) контроллера
volatile SemaphoreHandle_t timerSemaphore;
// Резервируем переменную блокировки - Spinlocks, форму аппаратного взаимного 
// исключения, которая обеспечивает механизм предотвращения доступа обоих CPU 
// на ESP32 к одному и тому же участку общих данных
portMUX_TYPE timerMux = portMUX_INITIALIZER_UNLOCKED;
// Резервируем счетчик прерываний
volatile uint32_t isrCounter = 0;
// Резервируем счетчик миллисекунд с начала запуска
volatile uint32_t lastIsrAt = 0;

// ***************************************************************************
// *                       Обработать прерывание от таймера                  *
// ***************************************************************************
void ARDUINO_ISR_ATTR onTimer() 
{
  // Блокируем память, изменяем значения счетчиков, снимаем блокировку
  portENTER_CRITICAL_ISR(&timerMux);
  isrCounter = isrCounter + 1;
  lastIsrAt = millis();
  portEXIT_CRITICAL_ISR(&timerMux);
  
  // Включаем семафор функцией xSemaphoreGiveFromISR(), который будет проверять 
  // в основном цикле контроллера. Такое взаимодействие используется, когда 
  // необходимо синхронизировать функцию обработки прерывания (ISR) и обычную задачу.
  // https://microsin.net/programming/arm/freertos-part3.html
  // Функция вызывается из функции обработки прерывания (ISR function). Двоичные 
  // семафоры могут использоваться для разблокировки задачи каждый раз, когда возникает 
  // какое-то отдельное прерывание, чем можно эффективно засинхронизировать задачу
  // с прерыванием. Это позволяет разместить почти весь код обработки события прерывания 
  // внутри синхронизированной задачи, оставляя в ISR только очень малую часть кода. 
  // Такая обработка прерывания называется 'отложенной' (deferred) для задачи - 
  // обработчика события.
  xSemaphoreGiveFromISR(timerSemaphore, NULL);
  
  // !!! в ISR можно безопасно использовать digitalRead/Write, если требуется
  // переключить вывод
}

void setup() 
{
  Serial.begin(115200);
  // Устанавливаем контакт BTN_STOP_ALARM на режим ввода
  pinMode(BTN_STOP_ALARM, INPUT);
  // Создаём семафор для фиксации срабатывания таймера
  timerSemaphore = xSemaphoreCreateBinary();
  // Запускаем таймер с частотой 1Mhz
  timer = timerBegin(1000000);
  // Подключаем обработчик OnTimer к нашему таймеру.
  timerAttachInterrupt(timer, &onTimer);
  // Обеспечиваем вызов обработчика каждую секунду (2 параметр указан в микросекундах),
  // третьим параметров указываем запускать таймер каждый раз. И так до бесконечности -
  // четвертый параметр (number of autoreloads, 0 = unlimited)
  timerAlarm(timer, 1000000, true, 0);
}

void loop() 
{
  // Если сработал таймер
  if (xSemaphoreTake(timerSemaphore, 0) == pdTRUE) 
  {
    // Инициируем счетчик прерываний и счетчик тиков (время с начала загрузки)
    uint32_t isrCount = 0, isrTime = 0;
    // Извлекаем значения счетчиков из защищенной области памяти
    portENTER_CRITICAL(&timerMux);
    isrCount = isrCounter;
    isrTime = lastIsrAt;
    portEXIT_CRITICAL(&timerMux);
    // Выводим значения
    Serial.print("onTimer no. ");
    Serial.print(isrCount);
    Serial.print(" at ");
    Serial.print(isrTime);
    Serial.println(" ms");
  }
  // Если нулевой пин заземлен, то останавливаем таймер
  if (digitalRead(BTN_STOP_ALARM) == LOW) 
  {
    // Если таймер все еще работает
    if (timer) 
    {
      // Останавливаем таймер и освобождаем память
      timerEnd(timer);
      timer = NULL;
    }
  }
}

// ***************************************************** 17-RepeatTimer.ino ***

