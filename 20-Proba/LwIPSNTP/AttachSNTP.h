/** Arduino, Esp32 ******************************************* AttachSNTP.h ***
 * 
 *         Подключится к пулу серверов точного времени и синхронизировать время 
 *                                                контроллера по протоколу SNTP
 * 
 * v1.0.1, 28.12.2024                                 Автор:      Труфанов В.Е.
 * Copyright © 2024 tve                               Дата создания: 27.12.2024
**/

#pragma once     
#include "Arduino.h"

// Некоторые временные зоны (часовые пояса):
// https://github.com/nayarsystems/posix_tz_db/blob/master/zones.csv

//   1 Africa/Abidjan     GMT0
//   2 Africa/Accra       GMT0
//  13 Africa/Cairo       EET-2EEST,M4.5.5/0,M10.5.4/24
//  14 Africa/Casablanca  <+01>-1
//  54 America/Anchorage  AKST9AKDT,M3.2.0,M11.1.0
//  85 America/Caracas    <-04>4
// 154 America/New_York   EST5EDT,M3.2.0,M11.1.0
// 350 Europe/Moscow      MSK-3
// 430 Etc/GMT-2          <+02>-2
// 431 Etc/GMT-3          <+03>-3

// Некоторые пулы серверов точного времени

// ru.pool.ntp.org   - Российская Федерация
// ntp.msk-ix.ru     - Москва, Столица Российской Федерации
// pool.ntp.org      - основной мировой пул точного времени
// time.google.com   - сервера Google: Google Public NTP [AS15169]
// time.windows.com  - сервера Microsoft NTP server [AS8075]

// Подключаем библиотеку для связи с сервером SNTP:

// - функция gettimeofday используется для получения текущей метки времени;
// - функция settimeofday используется для установки текущего времени при 
//   получении ответа от сервера NTP;
// - функция sntp_get_sync_status() используется для получения информации о 
//   состоянии синхронизации времени. Если время синхронизировано, то возвращается 
//   ответ SNTP_SYNC_RETURN_COMPLETED. Если состояние сброшено, то возвращается 
//   SNTP_SYC_STATUS_RESET. Кроме того, если происходит плавная синхронизация 
//   времени, то возвращается ответ SNTP_SYNC_STATUS_IN_PROGRESS;
// - функция sntp_set_sync_status() используется для установки статуса синхронизации 
//   времени. Она принимает один параметр — «sync_status», который является 
//   статусом синхронизации времени;
// - функция sntp_get_sync_mode() используется для получения режима синхронизации 
//   времени. Эта функция возвращает значение SNTP_SYNC_MODE_IMMEDIATE, если 
//   синхронизация настроена на немедленное обновление времени. В противном случае 
//   она возвращает SNTP_SYNC_MODE_SMOOTH - так как настроено плавное обновление времени;
// - функция sntp_set_sync_mode() используется для установки режима синхронизации 
//   времени. Она принимает один параметр «sync_mode», который является режимом 
//   синхронизации. Режим может быть SNTP_SYNC_MODE_IMMEDIATE или SNTP_SYNC_MODE_SMOOTH. 
//   Если выбран режим SNTP_SYNC_MODE_IMMEDIATE, системное время обновляется 
//   сразу после получения данных с сервера SNTP. Если выбран режим SNTP_SYNC_MODE_SMOOTH, 
//   устанавливается плавное обновление времени. В этом случае для уведомления 
//   о времени используется функция adjtime;
// - функция sntp_set_time_sync_notification_cb() используется для установки 
//   функции обратного вызова по уведомлению о синхронизации времени. Она 
//   принимает один параметр — функцию обратного вызова.

//   ESP32 использует два аппаратных таймера для отслеживания системного 
// времени: 
// - таймер RTC: позволяет отслеживать время в различных режимах сна, а также 
//   сохранять время при любых сбросах (за исключением сброса при включении питания, 
//   который сбрасывает таймер RTC). Отклонение частоты зависит от источников 
//   тактового сигнала таймера RTC и влияет на точность только в режимах сна, 
//   в которых время будет измеряться с точностью до 6,6667 мкс;
// - таймер с высоким разрешением: этот таймер недоступен в спящих режимах и не 
//   сохраняется после перезагрузки, но обладает большей точностью. Таймер 
//   использует источник тактовых импульсов APB_CLK (обычно 80 МГц), отклонение 
//   частоты которого составляет менее ±10 частей на миллион. Время измеряется с 
//   точностью до 1 мкс.
// Системное время можно отслеживать с помощью одного или обоих аппаратных 
// таймеров в зависимости от целей приложения и требований к точности системного 
// времени (при умалчиваемом режиме подключены оба таймера, это гарантирует, что 
// после синхронизации с сервером SNTP время будет отсчитываться с помощью обоих 
// таймеров. Когда плата ESP32 будет находиться в режиме глубокого сна, для отслеживания 
// времени будет использоваться встроенный таймер RTC, а таймер FRC1 с высоким 
// разрешением обеспечит точность времени до микросекунд, пока плата будет 
// находиться в активном режиме. 

#include "esp_sntp.h"

class TAttachSNTP
{
   public:

   // Определить объект (конструктор класса)
   TAttachSNTP(const char *server="ntp.msk-ix.ru");
   // Построить объект синхронизации времени                         
   void Create();
   // Извлечь и сформировать строку локальной информации о текущей дате и 
   // времени в типизированном виде: "2024-12-28 13:29:07"     
   String strTime(); 
   // Извлечь и сформировать строку о текущей дате и времени     
   // в указанной временной зоне (часовом поясе)               
   String strLocalTime(const char* value="MSK-3");
   // Узнать подключенный пул серверов точного времени
   String getservername();

   private:

   // Переменная локального времени (секунды с начала эпохи)
   time_t now;
   // Структура времени timeinfo в которую будем вкладывать
   // выбранное и преобразованное время в секундах с начала эпохи
   struct tm timeinfo;
   // Название пула серверов точного времени
   const char *ServerName;
   // Буфер для размещения строки с датой и временем
   char strftime_buf[64];
   // Настроить интервал синхронизации, имя сервера, режим работы и часовой пояс
   void initSNTP(); 
   // Настроить часовой пояс         
   void setTimezone(); 
   // Ожидать синхронизацию    
   void wait4SNTP(); 
   // Двузначное число представить в виде строки, 
   // в том числе, однозначное число дополнить слева нулем      
   String zfil2(int n); 
};

// *********************************************************** AttachSNTP.h ***
